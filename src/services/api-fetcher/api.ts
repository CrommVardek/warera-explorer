/* tslint:disable */
/* eslint-disable */
/**
 * WarEra API
 * WarEra tRPC API endpoints. ⚠️ Please notice that every call is in GET and not POST.
 *
 * The version of the OpenAPI document: 0.17.4-beta
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

export interface ArticleGetArticleByIdRequest {
  /**
   * The ID of the article to get
   */
  articleId: string;
}
export interface ArticleGetArticlesPaginatedRequest {
  /**
   * The type of articles to get
   */
  type: ArticleGetArticlesPaginatedRequestTypeEnum;
  /**
   * The limit of articles to get
   */
  limit?: number;
  cursor?: string;
  /**
   * The user ID to get articles for
   */
  userId?: string;
  /**
   * The categories to get articles for
   */
  categories?: Array<string>;
  /**
   * The languages to get articles for
   */
  languages?: Array<string>;
}

export const ArticleGetArticlesPaginatedRequestTypeEnum = {
  Weekly: "weekly",
  Top: "top",
  My: "my",
  Subscriptions: "subscriptions",
  Last: "last",
} as const;

export type ArticleGetArticlesPaginatedRequestTypeEnum =
  (typeof ArticleGetArticlesPaginatedRequestTypeEnum)[keyof typeof ArticleGetArticlesPaginatedRequestTypeEnum];

export interface BattleGetBattlesRequest {
  /**
   * Whether to get active battles
   */
  isActive?: boolean;
  /**
   * The limit of battles to get
   */
  limit?: number;
  /**
   * The cursor to get the next battles
   */
  cursor?: string;
  /**
   * The direction to get the battles
   */
  direction?: BattleGetBattlesRequestDirectionEnum;
  /**
   * Filter type for battles
   */
  filter?: BattleGetBattlesRequestFilterEnum;
  /**
   * Filter battles by defender region ID
   */
  defenderRegionId?: string;
  /**
   * Filter battles by war ID
   */
  warId?: string;
  /**
   * Filter battles by country ID
   */
  countryId?: string;
}

export const BattleGetBattlesRequestDirectionEnum = {
  Forward: "forward",
  Backward: "backward",
} as const;

export type BattleGetBattlesRequestDirectionEnum =
  (typeof BattleGetBattlesRequestDirectionEnum)[keyof typeof BattleGetBattlesRequestDirectionEnum];
export const BattleGetBattlesRequestFilterEnum = {
  All: "all",
  YourCountry: "yourCountry",
  YourEnemies: "yourEnemies",
} as const;

export type BattleGetBattlesRequestFilterEnum =
  (typeof BattleGetBattlesRequestFilterEnum)[keyof typeof BattleGetBattlesRequestFilterEnum];

export interface BattleGetByIdRequest {
  /**
   * The unique identifier of the battle
   */
  battleId: string;
}
export interface BattleGetLiveBattleDataRequest {
  /**
   * The unique identifier of the battle
   */
  battleId: string;
  /**
   * Optional specific round number to retrieve
   */
  roundNumber?: number;
}
export interface BattleRankingGetRankingRequest {
  /**
   * Optional battle ID to filter rankings
   */
  battleId?: string;
  /**
   * Optional round ID to filter rankings
   */
  roundId?: string;
  /**
   * Optional war ID to filter rankings
   */
  warId?: string;
  /**
   * Type of ranking data to retrieve (damage, ground points, or money)
   */
  dataType: BattleRankingGetRankingRequestDataTypeEnum;
  /**
   * Whether to rank by user or country
   */
  type: BattleRankingGetRankingRequestTypeEnum;
  /**
   * Which side of the battle to rank
   */
  side: BattleRankingGetRankingRequestSideEnum;
}

export const BattleRankingGetRankingRequestDataTypeEnum = {
  Damage: "damage",
  Points: "points",
  Money: "money",
} as const;

export type BattleRankingGetRankingRequestDataTypeEnum =
  (typeof BattleRankingGetRankingRequestDataTypeEnum)[keyof typeof BattleRankingGetRankingRequestDataTypeEnum];
export const BattleRankingGetRankingRequestTypeEnum = {
  User: "user",
  Country: "country",
  Mu: "mu",
} as const;

export type BattleRankingGetRankingRequestTypeEnum =
  (typeof BattleRankingGetRankingRequestTypeEnum)[keyof typeof BattleRankingGetRankingRequestTypeEnum];
export const BattleRankingGetRankingRequestSideEnum = {
  Attacker: "attacker",
  Defender: "defender",
} as const;

export type BattleRankingGetRankingRequestSideEnum =
  (typeof BattleRankingGetRankingRequestSideEnum)[keyof typeof BattleRankingGetRankingRequestSideEnum];

export interface CompanyGetByIdRequest {
  /**
   * The unique identifier of the company
   */
  companyId: string;
}
export interface CompanyGetCompaniesRequest {
  /**
   * Filter companies by user ID
   */
  userId?: string;
  /**
   * Filter companies by organization ID
   */
  orgId?: string;
  /**
   * Number of companies per page (1-100)
   */
  perPage?: number;
  /**
   * Pagination cursor for next page
   */
  cursor?: string;
}
export interface CountryGetCountryByIdRequest {
  /**
   * The unique identifier of the country
   */
  countryId: string;
}
export interface EventGetEventsPaginatedRequest {
  /**
   * The limit of events to get
   */
  limit?: number;
  /**
   * The cursor to get the next events
   */
  cursor?: string;
  /**
   * Filter events by country ID
   */
  countryId?: string;
}
export interface GovernmentGetByCountryIdRequest {
  /**
   * The unique identifier of the country
   */
  countryId: string;
}
export interface ItemOfferGetByIdRequest {
  itemOfferId: string;
}
export interface MuGetByIdRequest {
  muId: string;
}
export interface MuGetManyPaginatedRequest {
  limit?: number;
  cursor?: string;
  memberId?: string;
  userId?: string;
  orgId?: string;
  search?: string;
}
export interface RankingGetRankingRequest {
  /**
   * The type of ranking to retrieve
   */
  rankingType: RankingGetRankingRequestRankingTypeEnum;
}

export const RankingGetRankingRequestRankingTypeEnum = {
  WeeklyCountryDamages: "weeklyCountryDamages",
  WeeklyCountryDamagesPerCitizen: "weeklyCountryDamagesPerCitizen",
  CountryRegionDiff: "countryRegionDiff",
  CountryDevelopment: "countryDevelopment",
  CountryActivePopulation: "countryActivePopulation",
  CountryDamages: "countryDamages",
  CountryWealth: "countryWealth",
  CountryProductionBonus: "countryProductionBonus",
  WeeklyUserDamages: "weeklyUserDamages",
  UserDamages: "userDamages",
  UserWealth: "userWealth",
  UserLevel: "userLevel",
  UserReferrals: "userReferrals",
  UserSubscribers: "userSubscribers",
  UserTerrain: "userTerrain",
  UserPremiumMonths: "userPremiumMonths",
  UserPremiumGifts: "userPremiumGifts",
  UserCasesOpened: "userCasesOpened",
  UserGemsPurchased: "userGemsPurchased",
  MuWeeklyDamages: "muWeeklyDamages",
  MuDamages: "muDamages",
  MuTerrain: "muTerrain",
  MuWealth: "muWealth",
} as const;

export type RankingGetRankingRequestRankingTypeEnum =
  (typeof RankingGetRankingRequestRankingTypeEnum)[keyof typeof RankingGetRankingRequestRankingTypeEnum];

export interface RegionGetByIdRequest {
  /**
   * The unique identifier of the region
   */
  regionId: string;
}
export interface RoundGetByIdRequest {
  /**
   * The unique identifier of the round
   */
  roundId: string;
}
export interface SearchSearchAnythingRequest {
  /**
   * The search query string
   */
  searchText: string;
}
export interface TradingOrderGetTopOrdersRequest {
  /**
   * The item code to get orders for
   */
  itemCode: string;
  /**
   * The limit of orders to get
   */
  limit?: number;
}
export interface TransactionGetPaginatedTransactionsRequest {
  /**
   * The limit of transactions to get
   */
  limit?: number;
  /**
   * The cursor to get the next transactions
   */
  cursor?: string;
  /**
   * The user ID to get transactions for
   */
  userId?: string;
  /**
   * The MU ID to get transactions for
   */
  muId?: string;
  /**
   * The country ID to get transactions for
   */
  countryId?: string;
  /**
   * The item code to get transactions for
   */
  itemCode?: string;
  transactionType?: TransactionGetPaginatedTransactionsRequestTransactionType;
}
/**
 * The type of transactions to get
 */
export interface TransactionGetPaginatedTransactionsRequestTransactionType {}
export interface UpgradeGetUpgradeByTypeAndEntityRequest {
  /**
   * The upgrade type to get
   */
  upgradeType: UpgradeGetUpgradeByTypeAndEntityRequestUpgradeTypeEnum;
  /**
   * The region ID to get upgrade for
   */
  regionId?: string;
  /**
   * The company ID to get upgrade for
   */
  companyId?: string;
  /**
   * The military unit ID to get upgrade for
   */
  muId?: string;
}

export const UpgradeGetUpgradeByTypeAndEntityRequestUpgradeTypeEnum = {
  Bunker: "bunker",
  Base: "base",
  Storage: "storage",
  AutomatedEngine: "automatedEngine",
  BreakRoom: "breakRoom",
  Headquarters: "headquarters",
  Dormitories: "dormitories",
} as const;

export type UpgradeGetUpgradeByTypeAndEntityRequestUpgradeTypeEnum =
  (typeof UpgradeGetUpgradeByTypeAndEntityRequestUpgradeTypeEnum)[keyof typeof UpgradeGetUpgradeByTypeAndEntityRequestUpgradeTypeEnum];

export interface UserGetUserLiteRequest {
  /**
   * The unique identifier of the user
   */
  userId: string;
}
export interface UserGetUsersByCountryRequest {
  countryId: string;
  limit?: number;
  cursor?: string;
}
export interface WorkOfferGetByIdRequest {
  workOfferId: string;
}
export interface WorkOfferGetWorkOfferByCompanyIdRequest {
  companyId: string;
}
export interface WorkOfferGetWorkOffersPaginatedRequest {
  userId?: string;
  regionId?: string;
  cursor?: string;
  limit?: number;
}

/**
 * ArticleApi - axios parameter creator
 */
export const ArticleApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves detailed information about a specific article
     * @summary Get article by ID
     * @param {ArticleGetArticleByIdRequest} [articleGetArticleByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    articleGetArticleById: async (
      articleGetArticleByIdRequest?: ArticleGetArticleByIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/article.getArticleById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        articleGetArticleByIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a paginated list of articles
     * @summary Get paginated articles
     * @param {ArticleGetArticlesPaginatedRequest} [articleGetArticlesPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    articleGetArticlesPaginated: async (
      articleGetArticlesPaginatedRequest?: ArticleGetArticlesPaginatedRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/article.getArticlesPaginated`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        articleGetArticlesPaginatedRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ArticleApi - functional programming interface
 */
export const ArticleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ArticleApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves detailed information about a specific article
     * @summary Get article by ID
     * @param {ArticleGetArticleByIdRequest} [articleGetArticleByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async articleGetArticleById(
      articleGetArticleByIdRequest?: ArticleGetArticleByIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.articleGetArticleById(
          articleGetArticleByIdRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ArticleApi.articleGetArticleById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves a paginated list of articles
     * @summary Get paginated articles
     * @param {ArticleGetArticlesPaginatedRequest} [articleGetArticlesPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async articleGetArticlesPaginated(
      articleGetArticlesPaginatedRequest?: ArticleGetArticlesPaginatedRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.articleGetArticlesPaginated(
          articleGetArticlesPaginatedRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ArticleApi.articleGetArticlesPaginated"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ArticleApi - factory interface
 */
export const ArticleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ArticleApiFp(configuration);
  return {
    /**
     * Retrieves detailed information about a specific article
     * @summary Get article by ID
     * @param {ArticleGetArticleByIdRequest} [articleGetArticleByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    articleGetArticleById(
      articleGetArticleByIdRequest?: ArticleGetArticleByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .articleGetArticleById(articleGetArticleByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a paginated list of articles
     * @summary Get paginated articles
     * @param {ArticleGetArticlesPaginatedRequest} [articleGetArticlesPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    articleGetArticlesPaginated(
      articleGetArticlesPaginatedRequest?: ArticleGetArticlesPaginatedRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .articleGetArticlesPaginated(
          articleGetArticlesPaginatedRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ArticleApi - object-oriented interface
 */
export class ArticleApi extends BaseAPI {
  /**
   * Retrieves detailed information about a specific article
   * @summary Get article by ID
   * @param {ArticleGetArticleByIdRequest} [articleGetArticleByIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public articleGetArticleById(
    articleGetArticleByIdRequest?: ArticleGetArticleByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ArticleApiFp(this.configuration)
      .articleGetArticleById(articleGetArticleByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a paginated list of articles
   * @summary Get paginated articles
   * @param {ArticleGetArticlesPaginatedRequest} [articleGetArticlesPaginatedRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public articleGetArticlesPaginated(
    articleGetArticlesPaginatedRequest?: ArticleGetArticlesPaginatedRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ArticleApiFp(this.configuration)
      .articleGetArticlesPaginated(articleGetArticlesPaginatedRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BattleApi - axios parameter creator
 */
export const BattleApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves a list of battles
     * @summary Get battles
     * @param {BattleGetBattlesRequest} [battleGetBattlesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    battleGetBattles: async (
      battleGetBattlesRequest?: BattleGetBattlesRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/battle.getBattles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        battleGetBattlesRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves detailed information about a specific battle
     * @summary Get battle by ID
     * @param {BattleGetByIdRequest} [battleGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    battleGetById: async (
      battleGetByIdRequest?: BattleGetByIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/battle.getById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        battleGetByIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves real-time battle data including current round information
     * @summary Get live battle data
     * @param {BattleGetLiveBattleDataRequest} [battleGetLiveBattleDataRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    battleGetLiveBattleData: async (
      battleGetLiveBattleDataRequest?: BattleGetLiveBattleDataRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/battle.getLiveBattleData`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        battleGetLiveBattleDataRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BattleApi - functional programming interface
 */
export const BattleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BattleApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves a list of battles
     * @summary Get battles
     * @param {BattleGetBattlesRequest} [battleGetBattlesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async battleGetBattles(
      battleGetBattlesRequest?: BattleGetBattlesRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.battleGetBattles(
          battleGetBattlesRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BattleApi.battleGetBattles"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves detailed information about a specific battle
     * @summary Get battle by ID
     * @param {BattleGetByIdRequest} [battleGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async battleGetById(
      battleGetByIdRequest?: BattleGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.battleGetById(
        battleGetByIdRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BattleApi.battleGetById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves real-time battle data including current round information
     * @summary Get live battle data
     * @param {BattleGetLiveBattleDataRequest} [battleGetLiveBattleDataRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async battleGetLiveBattleData(
      battleGetLiveBattleDataRequest?: BattleGetLiveBattleDataRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.battleGetLiveBattleData(
          battleGetLiveBattleDataRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BattleApi.battleGetLiveBattleData"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BattleApi - factory interface
 */
export const BattleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BattleApiFp(configuration);
  return {
    /**
     * Retrieves a list of battles
     * @summary Get battles
     * @param {BattleGetBattlesRequest} [battleGetBattlesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    battleGetBattles(
      battleGetBattlesRequest?: BattleGetBattlesRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .battleGetBattles(battleGetBattlesRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves detailed information about a specific battle
     * @summary Get battle by ID
     * @param {BattleGetByIdRequest} [battleGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    battleGetById(
      battleGetByIdRequest?: BattleGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .battleGetById(battleGetByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves real-time battle data including current round information
     * @summary Get live battle data
     * @param {BattleGetLiveBattleDataRequest} [battleGetLiveBattleDataRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    battleGetLiveBattleData(
      battleGetLiveBattleDataRequest?: BattleGetLiveBattleDataRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .battleGetLiveBattleData(battleGetLiveBattleDataRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BattleApi - object-oriented interface
 */
export class BattleApi extends BaseAPI {
  /**
   * Retrieves a list of battles
   * @summary Get battles
   * @param {BattleGetBattlesRequest} [battleGetBattlesRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public battleGetBattles(
    battleGetBattlesRequest?: BattleGetBattlesRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BattleApiFp(this.configuration)
      .battleGetBattles(battleGetBattlesRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves detailed information about a specific battle
   * @summary Get battle by ID
   * @param {BattleGetByIdRequest} [battleGetByIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public battleGetById(
    battleGetByIdRequest?: BattleGetByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BattleApiFp(this.configuration)
      .battleGetById(battleGetByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves real-time battle data including current round information
   * @summary Get live battle data
   * @param {BattleGetLiveBattleDataRequest} [battleGetLiveBattleDataRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public battleGetLiveBattleData(
    battleGetLiveBattleDataRequest?: BattleGetLiveBattleDataRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BattleApiFp(this.configuration)
      .battleGetLiveBattleData(battleGetLiveBattleDataRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BattleRankingApi - axios parameter creator
 */
export const BattleRankingApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves damage, ground, or money rankings for users or countries in battles, rounds, or wars
     * @summary Get battle rankings
     * @param {BattleRankingGetRankingRequest} [battleRankingGetRankingRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    battleRankingGetRanking: async (
      battleRankingGetRankingRequest?: BattleRankingGetRankingRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/battleRanking.getRanking`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        battleRankingGetRankingRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BattleRankingApi - functional programming interface
 */
export const BattleRankingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    BattleRankingApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves damage, ground, or money rankings for users or countries in battles, rounds, or wars
     * @summary Get battle rankings
     * @param {BattleRankingGetRankingRequest} [battleRankingGetRankingRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async battleRankingGetRanking(
      battleRankingGetRankingRequest?: BattleRankingGetRankingRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.battleRankingGetRanking(
          battleRankingGetRankingRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BattleRankingApi.battleRankingGetRanking"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BattleRankingApi - factory interface
 */
export const BattleRankingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BattleRankingApiFp(configuration);
  return {
    /**
     * Retrieves damage, ground, or money rankings for users or countries in battles, rounds, or wars
     * @summary Get battle rankings
     * @param {BattleRankingGetRankingRequest} [battleRankingGetRankingRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    battleRankingGetRanking(
      battleRankingGetRankingRequest?: BattleRankingGetRankingRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .battleRankingGetRanking(battleRankingGetRankingRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BattleRankingApi - object-oriented interface
 */
export class BattleRankingApi extends BaseAPI {
  /**
   * Retrieves damage, ground, or money rankings for users or countries in battles, rounds, or wars
   * @summary Get battle rankings
   * @param {BattleRankingGetRankingRequest} [battleRankingGetRankingRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public battleRankingGetRanking(
    battleRankingGetRankingRequest?: BattleRankingGetRankingRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BattleRankingApiFp(this.configuration)
      .battleRankingGetRanking(battleRankingGetRankingRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CompanyApi - axios parameter creator
 */
export const CompanyApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves detailed information about a specific company
     * @summary Get company by ID
     * @param {CompanyGetByIdRequest} [companyGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    companyGetById: async (
      companyGetByIdRequest?: CompanyGetByIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/company.getById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        companyGetByIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a paginated list of companies with optional filtering
     * @summary Get companies with pagination
     * @param {CompanyGetCompaniesRequest} [companyGetCompaniesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    companyGetCompanies: async (
      companyGetCompaniesRequest?: CompanyGetCompaniesRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/company.getCompanies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        companyGetCompaniesRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CompanyApi - functional programming interface
 */
export const CompanyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CompanyApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves detailed information about a specific company
     * @summary Get company by ID
     * @param {CompanyGetByIdRequest} [companyGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async companyGetById(
      companyGetByIdRequest?: CompanyGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.companyGetById(
        companyGetByIdRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CompanyApi.companyGetById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves a paginated list of companies with optional filtering
     * @summary Get companies with pagination
     * @param {CompanyGetCompaniesRequest} [companyGetCompaniesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async companyGetCompanies(
      companyGetCompaniesRequest?: CompanyGetCompaniesRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.companyGetCompanies(
          companyGetCompaniesRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CompanyApi.companyGetCompanies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CompanyApi - factory interface
 */
export const CompanyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CompanyApiFp(configuration);
  return {
    /**
     * Retrieves detailed information about a specific company
     * @summary Get company by ID
     * @param {CompanyGetByIdRequest} [companyGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    companyGetById(
      companyGetByIdRequest?: CompanyGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .companyGetById(companyGetByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a paginated list of companies with optional filtering
     * @summary Get companies with pagination
     * @param {CompanyGetCompaniesRequest} [companyGetCompaniesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    companyGetCompanies(
      companyGetCompaniesRequest?: CompanyGetCompaniesRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .companyGetCompanies(companyGetCompaniesRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CompanyApi - object-oriented interface
 */
export class CompanyApi extends BaseAPI {
  /**
   * Retrieves detailed information about a specific company
   * @summary Get company by ID
   * @param {CompanyGetByIdRequest} [companyGetByIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public companyGetById(
    companyGetByIdRequest?: CompanyGetByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return CompanyApiFp(this.configuration)
      .companyGetById(companyGetByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a paginated list of companies with optional filtering
   * @summary Get companies with pagination
   * @param {CompanyGetCompaniesRequest} [companyGetCompaniesRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public companyGetCompanies(
    companyGetCompaniesRequest?: CompanyGetCompaniesRequest,
    options?: RawAxiosRequestConfig
  ) {
    return CompanyApiFp(this.configuration)
      .companyGetCompanies(companyGetCompaniesRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CountryApi - axios parameter creator
 */
export const CountryApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves a list of all available countries
     * @summary Get all countries
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countryGetAllCountries: async (
      body?: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/country.getAllCountries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves detailed information about a specific country
     * @summary Get country by ID
     * @param {CountryGetCountryByIdRequest} [countryGetCountryByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countryGetCountryById: async (
      countryGetCountryByIdRequest?: CountryGetCountryByIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/country.getCountryById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        countryGetCountryByIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CountryApi - functional programming interface
 */
export const CountryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CountryApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves a list of all available countries
     * @summary Get all countries
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countryGetAllCountries(
      body?: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.countryGetAllCountries(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CountryApi.countryGetAllCountries"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves detailed information about a specific country
     * @summary Get country by ID
     * @param {CountryGetCountryByIdRequest} [countryGetCountryByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countryGetCountryById(
      countryGetCountryByIdRequest?: CountryGetCountryByIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.countryGetCountryById(
          countryGetCountryByIdRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CountryApi.countryGetCountryById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CountryApi - factory interface
 */
export const CountryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CountryApiFp(configuration);
  return {
    /**
     * Retrieves a list of all available countries
     * @summary Get all countries
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countryGetAllCountries(
      body?: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .countryGetAllCountries(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves detailed information about a specific country
     * @summary Get country by ID
     * @param {CountryGetCountryByIdRequest} [countryGetCountryByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countryGetCountryById(
      countryGetCountryByIdRequest?: CountryGetCountryByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .countryGetCountryById(countryGetCountryByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CountryApi - object-oriented interface
 */
export class CountryApi extends BaseAPI {
  /**
   * Retrieves a list of all available countries
   * @summary Get all countries
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public countryGetAllCountries(
    body?: object,
    options?: RawAxiosRequestConfig
  ) {
    return CountryApiFp(this.configuration)
      .countryGetAllCountries(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves detailed information about a specific country
   * @summary Get country by ID
   * @param {CountryGetCountryByIdRequest} [countryGetCountryByIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public countryGetCountryById(
    countryGetCountryByIdRequest?: CountryGetCountryByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return CountryApiFp(this.configuration)
      .countryGetCountryById(countryGetCountryByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EventApi - axios parameter creator
 */
export const EventApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves a paginated list of events with optional country filter
     * @summary Get paginated events
     * @param {EventGetEventsPaginatedRequest} [eventGetEventsPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventGetEventsPaginated: async (
      eventGetEventsPaginatedRequest?: EventGetEventsPaginatedRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/event.getEventsPaginated`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eventGetEventsPaginatedRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EventApi - functional programming interface
 */
export const EventApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves a paginated list of events with optional country filter
     * @summary Get paginated events
     * @param {EventGetEventsPaginatedRequest} [eventGetEventsPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eventGetEventsPaginated(
      eventGetEventsPaginatedRequest?: EventGetEventsPaginatedRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eventGetEventsPaginated(
          eventGetEventsPaginatedRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["EventApi.eventGetEventsPaginated"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * EventApi - factory interface
 */
export const EventApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EventApiFp(configuration);
  return {
    /**
     * Retrieves a paginated list of events with optional country filter
     * @summary Get paginated events
     * @param {EventGetEventsPaginatedRequest} [eventGetEventsPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventGetEventsPaginated(
      eventGetEventsPaginatedRequest?: EventGetEventsPaginatedRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .eventGetEventsPaginated(eventGetEventsPaginatedRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EventApi - object-oriented interface
 */
export class EventApi extends BaseAPI {
  /**
   * Retrieves a paginated list of events with optional country filter
   * @summary Get paginated events
   * @param {EventGetEventsPaginatedRequest} [eventGetEventsPaginatedRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public eventGetEventsPaginated(
    eventGetEventsPaginatedRequest?: EventGetEventsPaginatedRequest,
    options?: RawAxiosRequestConfig
  ) {
    return EventApiFp(this.configuration)
      .eventGetEventsPaginated(eventGetEventsPaginatedRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GameConfigApi - axios parameter creator
 */
export const GameConfigApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves game-related dates and timings
     * @summary Get game dates
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameConfigGetDates: async (
      body?: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/gameConfig.getDates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves static game configuration
     * @summary Get game configuration
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameConfigGetGameConfig: async (
      body?: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/gameConfig.getGameConfig`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GameConfigApi - functional programming interface
 */
export const GameConfigApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    GameConfigApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves game-related dates and timings
     * @summary Get game dates
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameConfigGetDates(
      body?: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.gameConfigGetDates(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["GameConfigApi.gameConfigGetDates"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves static game configuration
     * @summary Get game configuration
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameConfigGetGameConfig(
      body?: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.gameConfigGetGameConfig(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["GameConfigApi.gameConfigGetGameConfig"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * GameConfigApi - factory interface
 */
export const GameConfigApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = GameConfigApiFp(configuration);
  return {
    /**
     * Retrieves game-related dates and timings
     * @summary Get game dates
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameConfigGetDates(
      body?: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .gameConfigGetDates(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves static game configuration
     * @summary Get game configuration
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameConfigGetGameConfig(
      body?: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .gameConfigGetGameConfig(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GameConfigApi - object-oriented interface
 */
export class GameConfigApi extends BaseAPI {
  /**
   * Retrieves game-related dates and timings
   * @summary Get game dates
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public gameConfigGetDates(body?: object, options?: RawAxiosRequestConfig) {
    return GameConfigApiFp(this.configuration)
      .gameConfigGetDates(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves static game configuration
   * @summary Get game configuration
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public gameConfigGetGameConfig(
    body?: object,
    options?: RawAxiosRequestConfig
  ) {
    return GameConfigApiFp(this.configuration)
      .gameConfigGetGameConfig(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GovernmentApi - axios parameter creator
 */
export const GovernmentApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves government information for a specific country
     * @summary Get government by country ID
     * @param {GovernmentGetByCountryIdRequest} [governmentGetByCountryIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    governmentGetByCountryId: async (
      governmentGetByCountryIdRequest?: GovernmentGetByCountryIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/government.getByCountryId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        governmentGetByCountryIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GovernmentApi - functional programming interface
 */
export const GovernmentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    GovernmentApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves government information for a specific country
     * @summary Get government by country ID
     * @param {GovernmentGetByCountryIdRequest} [governmentGetByCountryIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async governmentGetByCountryId(
      governmentGetByCountryIdRequest?: GovernmentGetByCountryIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.governmentGetByCountryId(
          governmentGetByCountryIdRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["GovernmentApi.governmentGetByCountryId"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * GovernmentApi - factory interface
 */
export const GovernmentApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = GovernmentApiFp(configuration);
  return {
    /**
     * Retrieves government information for a specific country
     * @summary Get government by country ID
     * @param {GovernmentGetByCountryIdRequest} [governmentGetByCountryIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    governmentGetByCountryId(
      governmentGetByCountryIdRequest?: GovernmentGetByCountryIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .governmentGetByCountryId(governmentGetByCountryIdRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GovernmentApi - object-oriented interface
 */
export class GovernmentApi extends BaseAPI {
  /**
   * Retrieves government information for a specific country
   * @summary Get government by country ID
   * @param {GovernmentGetByCountryIdRequest} [governmentGetByCountryIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public governmentGetByCountryId(
    governmentGetByCountryIdRequest?: GovernmentGetByCountryIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return GovernmentApiFp(this.configuration)
      .governmentGetByCountryId(governmentGetByCountryIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ItemOfferApi - axios parameter creator
 */
export const ItemOfferApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves detailed information about a specific item offer
     * @summary Get item offer by ID
     * @param {ItemOfferGetByIdRequest} [itemOfferGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemOfferGetById: async (
      itemOfferGetByIdRequest?: ItemOfferGetByIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/itemOffer.getById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemOfferGetByIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ItemOfferApi - functional programming interface
 */
export const ItemOfferApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ItemOfferApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves detailed information about a specific item offer
     * @summary Get item offer by ID
     * @param {ItemOfferGetByIdRequest} [itemOfferGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async itemOfferGetById(
      itemOfferGetByIdRequest?: ItemOfferGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.itemOfferGetById(
          itemOfferGetByIdRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ItemOfferApi.itemOfferGetById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ItemOfferApi - factory interface
 */
export const ItemOfferApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ItemOfferApiFp(configuration);
  return {
    /**
     * Retrieves detailed information about a specific item offer
     * @summary Get item offer by ID
     * @param {ItemOfferGetByIdRequest} [itemOfferGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemOfferGetById(
      itemOfferGetByIdRequest?: ItemOfferGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .itemOfferGetById(itemOfferGetByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ItemOfferApi - object-oriented interface
 */
export class ItemOfferApi extends BaseAPI {
  /**
   * Retrieves detailed information about a specific item offer
   * @summary Get item offer by ID
   * @param {ItemOfferGetByIdRequest} [itemOfferGetByIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public itemOfferGetById(
    itemOfferGetByIdRequest?: ItemOfferGetByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ItemOfferApiFp(this.configuration)
      .itemOfferGetById(itemOfferGetByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ItemTradingApi - axios parameter creator
 */
export const ItemTradingApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves current market prices for all tradeable items
     * @summary Get item prices
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemTradingGetPrices: async (
      body?: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/itemTrading.getPrices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ItemTradingApi - functional programming interface
 */
export const ItemTradingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ItemTradingApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves current market prices for all tradeable items
     * @summary Get item prices
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async itemTradingGetPrices(
      body?: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.itemTradingGetPrices(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ItemTradingApi.itemTradingGetPrices"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ItemTradingApi - factory interface
 */
export const ItemTradingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ItemTradingApiFp(configuration);
  return {
    /**
     * Retrieves current market prices for all tradeable items
     * @summary Get item prices
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemTradingGetPrices(
      body?: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .itemTradingGetPrices(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ItemTradingApi - object-oriented interface
 */
export class ItemTradingApi extends BaseAPI {
  /**
   * Retrieves current market prices for all tradeable items
   * @summary Get item prices
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public itemTradingGetPrices(body?: object, options?: RawAxiosRequestConfig) {
    return ItemTradingApiFp(this.configuration)
      .itemTradingGetPrices(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MuApi - axios parameter creator
 */
export const MuApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Retrieves detailed information about a specific military unit
     * @summary Get military unit by ID
     * @param {MuGetByIdRequest} [muGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    muGetById: async (
      muGetByIdRequest?: MuGetByIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/mu.getById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        muGetByIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a paginated list of military units with optional filters
     * @summary Get military units (paginated)
     * @param {MuGetManyPaginatedRequest} [muGetManyPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    muGetManyPaginated: async (
      muGetManyPaginatedRequest?: MuGetManyPaginatedRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/mu.getManyPaginated`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        muGetManyPaginatedRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MuApi - functional programming interface
 */
export const MuApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MuApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves detailed information about a specific military unit
     * @summary Get military unit by ID
     * @param {MuGetByIdRequest} [muGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async muGetById(
      muGetByIdRequest?: MuGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.muGetById(
        muGetByIdRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MuApi.muGetById"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves a paginated list of military units with optional filters
     * @summary Get military units (paginated)
     * @param {MuGetManyPaginatedRequest} [muGetManyPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async muGetManyPaginated(
      muGetManyPaginatedRequest?: MuGetManyPaginatedRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.muGetManyPaginated(
          muGetManyPaginatedRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MuApi.muGetManyPaginated"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MuApi - factory interface
 */
export const MuApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MuApiFp(configuration);
  return {
    /**
     * Retrieves detailed information about a specific military unit
     * @summary Get military unit by ID
     * @param {MuGetByIdRequest} [muGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    muGetById(
      muGetByIdRequest?: MuGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .muGetById(muGetByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a paginated list of military units with optional filters
     * @summary Get military units (paginated)
     * @param {MuGetManyPaginatedRequest} [muGetManyPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    muGetManyPaginated(
      muGetManyPaginatedRequest?: MuGetManyPaginatedRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .muGetManyPaginated(muGetManyPaginatedRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MuApi - object-oriented interface
 */
export class MuApi extends BaseAPI {
  /**
   * Retrieves detailed information about a specific military unit
   * @summary Get military unit by ID
   * @param {MuGetByIdRequest} [muGetByIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public muGetById(
    muGetByIdRequest?: MuGetByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MuApiFp(this.configuration)
      .muGetById(muGetByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a paginated list of military units with optional filters
   * @summary Get military units (paginated)
   * @param {MuGetManyPaginatedRequest} [muGetManyPaginatedRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public muGetManyPaginated(
    muGetManyPaginatedRequest?: MuGetManyPaginatedRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MuApiFp(this.configuration)
      .muGetManyPaginated(muGetManyPaginatedRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RankingApi - axios parameter creator
 */
export const RankingApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves ranking data for the specified ranking type and optional year-week filter
     * @summary Get ranking data
     * @param {RankingGetRankingRequest} [rankingGetRankingRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rankingGetRanking: async (
      rankingGetRankingRequest?: RankingGetRankingRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/ranking.getRanking`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        rankingGetRankingRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RankingApi - functional programming interface
 */
export const RankingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RankingApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves ranking data for the specified ranking type and optional year-week filter
     * @summary Get ranking data
     * @param {RankingGetRankingRequest} [rankingGetRankingRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rankingGetRanking(
      rankingGetRankingRequest?: RankingGetRankingRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.rankingGetRanking(
          rankingGetRankingRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RankingApi.rankingGetRanking"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RankingApi - factory interface
 */
export const RankingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RankingApiFp(configuration);
  return {
    /**
     * Retrieves ranking data for the specified ranking type and optional year-week filter
     * @summary Get ranking data
     * @param {RankingGetRankingRequest} [rankingGetRankingRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rankingGetRanking(
      rankingGetRankingRequest?: RankingGetRankingRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .rankingGetRanking(rankingGetRankingRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RankingApi - object-oriented interface
 */
export class RankingApi extends BaseAPI {
  /**
   * Retrieves ranking data for the specified ranking type and optional year-week filter
   * @summary Get ranking data
   * @param {RankingGetRankingRequest} [rankingGetRankingRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rankingGetRanking(
    rankingGetRankingRequest?: RankingGetRankingRequest,
    options?: RawAxiosRequestConfig
  ) {
    return RankingApiFp(this.configuration)
      .rankingGetRanking(rankingGetRankingRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RegionApi - axios parameter creator
 */
export const RegionApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves detailed information about a specific region
     * @summary Get region by ID
     * @param {RegionGetByIdRequest} [regionGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regionGetById: async (
      regionGetByIdRequest?: RegionGetByIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/region.getById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        regionGetByIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a complete object containing all available regions
     * @summary Get all regions
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regionGetRegionsObject: async (
      body?: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/region.getRegionsObject`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RegionApi - functional programming interface
 */
export const RegionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RegionApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves detailed information about a specific region
     * @summary Get region by ID
     * @param {RegionGetByIdRequest} [regionGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async regionGetById(
      regionGetByIdRequest?: RegionGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.regionGetById(
        regionGetByIdRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RegionApi.regionGetById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves a complete object containing all available regions
     * @summary Get all regions
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async regionGetRegionsObject(
      body?: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.regionGetRegionsObject(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RegionApi.regionGetRegionsObject"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RegionApi - factory interface
 */
export const RegionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RegionApiFp(configuration);
  return {
    /**
     * Retrieves detailed information about a specific region
     * @summary Get region by ID
     * @param {RegionGetByIdRequest} [regionGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regionGetById(
      regionGetByIdRequest?: RegionGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .regionGetById(regionGetByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a complete object containing all available regions
     * @summary Get all regions
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regionGetRegionsObject(
      body?: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .regionGetRegionsObject(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RegionApi - object-oriented interface
 */
export class RegionApi extends BaseAPI {
  /**
   * Retrieves detailed information about a specific region
   * @summary Get region by ID
   * @param {RegionGetByIdRequest} [regionGetByIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public regionGetById(
    regionGetByIdRequest?: RegionGetByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return RegionApiFp(this.configuration)
      .regionGetById(regionGetByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a complete object containing all available regions
   * @summary Get all regions
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public regionGetRegionsObject(
    body?: object,
    options?: RawAxiosRequestConfig
  ) {
    return RegionApiFp(this.configuration)
      .regionGetRegionsObject(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RoundApi - axios parameter creator
 */
export const RoundApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves detailed information about a specific battle round
     * @summary Get round by ID
     * @param {RoundGetByIdRequest} [roundGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roundGetById: async (
      roundGetByIdRequest?: RoundGetByIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/round.getById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roundGetByIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the most recent hits/damages in a specific battle round
     * @summary Get last hits in round
     * @param {RoundGetByIdRequest} [roundGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roundGetLastHits: async (
      roundGetByIdRequest?: RoundGetByIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/round.getLastHits`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roundGetByIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RoundApi - functional programming interface
 */
export const RoundApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RoundApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves detailed information about a specific battle round
     * @summary Get round by ID
     * @param {RoundGetByIdRequest} [roundGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async roundGetById(
      roundGetByIdRequest?: RoundGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.roundGetById(
        roundGetByIdRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RoundApi.roundGetById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves the most recent hits/damages in a specific battle round
     * @summary Get last hits in round
     * @param {RoundGetByIdRequest} [roundGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async roundGetLastHits(
      roundGetByIdRequest?: RoundGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.roundGetLastHits(
          roundGetByIdRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RoundApi.roundGetLastHits"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RoundApi - factory interface
 */
export const RoundApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RoundApiFp(configuration);
  return {
    /**
     * Retrieves detailed information about a specific battle round
     * @summary Get round by ID
     * @param {RoundGetByIdRequest} [roundGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roundGetById(
      roundGetByIdRequest?: RoundGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .roundGetById(roundGetByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the most recent hits/damages in a specific battle round
     * @summary Get last hits in round
     * @param {RoundGetByIdRequest} [roundGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roundGetLastHits(
      roundGetByIdRequest?: RoundGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .roundGetLastHits(roundGetByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RoundApi - object-oriented interface
 */
export class RoundApi extends BaseAPI {
  /**
   * Retrieves detailed information about a specific battle round
   * @summary Get round by ID
   * @param {RoundGetByIdRequest} [roundGetByIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public roundGetById(
    roundGetByIdRequest?: RoundGetByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return RoundApiFp(this.configuration)
      .roundGetById(roundGetByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the most recent hits/damages in a specific battle round
   * @summary Get last hits in round
   * @param {RoundGetByIdRequest} [roundGetByIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public roundGetLastHits(
    roundGetByIdRequest?: RoundGetByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return RoundApiFp(this.configuration)
      .roundGetLastHits(roundGetByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SearchApi - axios parameter creator
 */
export const SearchApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Performs a global search across users, companies, articles, and other entities
     * @summary Global search
     * @param {SearchSearchAnythingRequest} [searchSearchAnythingRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSearchAnything: async (
      searchSearchAnythingRequest?: SearchSearchAnythingRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/search.searchAnything`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchSearchAnythingRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SearchApi - functional programming interface
 */
export const SearchApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration);
  return {
    /**
     * Performs a global search across users, companies, articles, and other entities
     * @summary Global search
     * @param {SearchSearchAnythingRequest} [searchSearchAnythingRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchSearchAnything(
      searchSearchAnythingRequest?: SearchSearchAnythingRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchSearchAnything(
          searchSearchAnythingRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SearchApi.searchSearchAnything"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SearchApi - factory interface
 */
export const SearchApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SearchApiFp(configuration);
  return {
    /**
     * Performs a global search across users, companies, articles, and other entities
     * @summary Global search
     * @param {SearchSearchAnythingRequest} [searchSearchAnythingRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSearchAnything(
      searchSearchAnythingRequest?: SearchSearchAnythingRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .searchSearchAnything(searchSearchAnythingRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SearchApi - object-oriented interface
 */
export class SearchApi extends BaseAPI {
  /**
   * Performs a global search across users, companies, articles, and other entities
   * @summary Global search
   * @param {SearchSearchAnythingRequest} [searchSearchAnythingRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public searchSearchAnything(
    searchSearchAnythingRequest?: SearchSearchAnythingRequest,
    options?: RawAxiosRequestConfig
  ) {
    return SearchApiFp(this.configuration)
      .searchSearchAnything(searchSearchAnythingRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TradingOrderApi - axios parameter creator
 */
export const TradingOrderApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves the best orders for an item
     * @summary Get best orders for an item
     * @param {TradingOrderGetTopOrdersRequest} [tradingOrderGetTopOrdersRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tradingOrderGetTopOrders: async (
      tradingOrderGetTopOrdersRequest?: TradingOrderGetTopOrdersRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tradingOrder.getTopOrders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tradingOrderGetTopOrdersRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TradingOrderApi - functional programming interface
 */
export const TradingOrderApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TradingOrderApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves the best orders for an item
     * @summary Get best orders for an item
     * @param {TradingOrderGetTopOrdersRequest} [tradingOrderGetTopOrdersRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tradingOrderGetTopOrders(
      tradingOrderGetTopOrdersRequest?: TradingOrderGetTopOrdersRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tradingOrderGetTopOrders(
          tradingOrderGetTopOrdersRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TradingOrderApi.tradingOrderGetTopOrders"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TradingOrderApi - factory interface
 */
export const TradingOrderApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TradingOrderApiFp(configuration);
  return {
    /**
     * Retrieves the best orders for an item
     * @summary Get best orders for an item
     * @param {TradingOrderGetTopOrdersRequest} [tradingOrderGetTopOrdersRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tradingOrderGetTopOrders(
      tradingOrderGetTopOrdersRequest?: TradingOrderGetTopOrdersRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .tradingOrderGetTopOrders(tradingOrderGetTopOrdersRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TradingOrderApi - object-oriented interface
 */
export class TradingOrderApi extends BaseAPI {
  /**
   * Retrieves the best orders for an item
   * @summary Get best orders for an item
   * @param {TradingOrderGetTopOrdersRequest} [tradingOrderGetTopOrdersRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public tradingOrderGetTopOrders(
    tradingOrderGetTopOrdersRequest?: TradingOrderGetTopOrdersRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TradingOrderApiFp(this.configuration)
      .tradingOrderGetTopOrders(tradingOrderGetTopOrdersRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TransactionApi - axios parameter creator
 */
export const TransactionApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves a paginated list of transactions
     * @summary Get paginated transactions
     * @param {TransactionGetPaginatedTransactionsRequest} [transactionGetPaginatedTransactionsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionGetPaginatedTransactions: async (
      transactionGetPaginatedTransactionsRequest?: TransactionGetPaginatedTransactionsRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/transaction.getPaginatedTransactions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        transactionGetPaginatedTransactionsRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransactionApi - functional programming interface
 */
export const TransactionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TransactionApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves a paginated list of transactions
     * @summary Get paginated transactions
     * @param {TransactionGetPaginatedTransactionsRequest} [transactionGetPaginatedTransactionsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transactionGetPaginatedTransactions(
      transactionGetPaginatedTransactionsRequest?: TransactionGetPaginatedTransactionsRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.transactionGetPaginatedTransactions(
          transactionGetPaginatedTransactionsRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "TransactionApi.transactionGetPaginatedTransactions"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TransactionApi - factory interface
 */
export const TransactionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TransactionApiFp(configuration);
  return {
    /**
     * Retrieves a paginated list of transactions
     * @summary Get paginated transactions
     * @param {TransactionGetPaginatedTransactionsRequest} [transactionGetPaginatedTransactionsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionGetPaginatedTransactions(
      transactionGetPaginatedTransactionsRequest?: TransactionGetPaginatedTransactionsRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .transactionGetPaginatedTransactions(
          transactionGetPaginatedTransactionsRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TransactionApi - object-oriented interface
 */
export class TransactionApi extends BaseAPI {
  /**
   * Retrieves a paginated list of transactions
   * @summary Get paginated transactions
   * @param {TransactionGetPaginatedTransactionsRequest} [transactionGetPaginatedTransactionsRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public transactionGetPaginatedTransactions(
    transactionGetPaginatedTransactionsRequest?: TransactionGetPaginatedTransactionsRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TransactionApiFp(this.configuration)
      .transactionGetPaginatedTransactions(
        transactionGetPaginatedTransactionsRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UpgradeApi - axios parameter creator
 */
export const UpgradeApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves upgrade information for a specific upgrade type and entity (region, company, or military unit)
     * @summary Get upgrade by type and entity
     * @param {UpgradeGetUpgradeByTypeAndEntityRequest} [upgradeGetUpgradeByTypeAndEntityRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeGetUpgradeByTypeAndEntity: async (
      upgradeGetUpgradeByTypeAndEntityRequest?: UpgradeGetUpgradeByTypeAndEntityRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/upgrade.getUpgradeByTypeAndEntity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        upgradeGetUpgradeByTypeAndEntityRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UpgradeApi - functional programming interface
 */
export const UpgradeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UpgradeApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves upgrade information for a specific upgrade type and entity (region, company, or military unit)
     * @summary Get upgrade by type and entity
     * @param {UpgradeGetUpgradeByTypeAndEntityRequest} [upgradeGetUpgradeByTypeAndEntityRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async upgradeGetUpgradeByTypeAndEntity(
      upgradeGetUpgradeByTypeAndEntityRequest?: UpgradeGetUpgradeByTypeAndEntityRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.upgradeGetUpgradeByTypeAndEntity(
          upgradeGetUpgradeByTypeAndEntityRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UpgradeApi.upgradeGetUpgradeByTypeAndEntity"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UpgradeApi - factory interface
 */
export const UpgradeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UpgradeApiFp(configuration);
  return {
    /**
     * Retrieves upgrade information for a specific upgrade type and entity (region, company, or military unit)
     * @summary Get upgrade by type and entity
     * @param {UpgradeGetUpgradeByTypeAndEntityRequest} [upgradeGetUpgradeByTypeAndEntityRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeGetUpgradeByTypeAndEntity(
      upgradeGetUpgradeByTypeAndEntityRequest?: UpgradeGetUpgradeByTypeAndEntityRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .upgradeGetUpgradeByTypeAndEntity(
          upgradeGetUpgradeByTypeAndEntityRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UpgradeApi - object-oriented interface
 */
export class UpgradeApi extends BaseAPI {
  /**
   * Retrieves upgrade information for a specific upgrade type and entity (region, company, or military unit)
   * @summary Get upgrade by type and entity
   * @param {UpgradeGetUpgradeByTypeAndEntityRequest} [upgradeGetUpgradeByTypeAndEntityRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public upgradeGetUpgradeByTypeAndEntity(
    upgradeGetUpgradeByTypeAndEntityRequest?: UpgradeGetUpgradeByTypeAndEntityRequest,
    options?: RawAxiosRequestConfig
  ) {
    return UpgradeApiFp(this.configuration)
      .upgradeGetUpgradeByTypeAndEntity(
        upgradeGetUpgradeByTypeAndEntityRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves basic public information about a user including username, skills, and rankings
     * @summary Get user profile (lite)
     * @param {UserGetUserLiteRequest} [userGetUserLiteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userGetUserLite: async (
      userGetUserLiteRequest?: UserGetUserLiteRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user.getUserLite`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userGetUserLiteRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a list of users by country
     * @summary Get users by country
     * @param {UserGetUsersByCountryRequest} [userGetUsersByCountryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userGetUsersByCountry: async (
      userGetUsersByCountryRequest?: UserGetUsersByCountryRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user.getUsersByCountry`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userGetUsersByCountryRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves basic public information about a user including username, skills, and rankings
     * @summary Get user profile (lite)
     * @param {UserGetUserLiteRequest} [userGetUserLiteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userGetUserLite(
      userGetUserLiteRequest?: UserGetUserLiteRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userGetUserLite(
        userGetUserLiteRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.userGetUserLite"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves a list of users by country
     * @summary Get users by country
     * @param {UserGetUsersByCountryRequest} [userGetUsersByCountryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userGetUsersByCountry(
      userGetUsersByCountryRequest?: UserGetUsersByCountryRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userGetUsersByCountry(
          userGetUsersByCountryRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.userGetUsersByCountry"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     * Retrieves basic public information about a user including username, skills, and rankings
     * @summary Get user profile (lite)
     * @param {UserGetUserLiteRequest} [userGetUserLiteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userGetUserLite(
      userGetUserLiteRequest?: UserGetUserLiteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .userGetUserLite(userGetUserLiteRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a list of users by country
     * @summary Get users by country
     * @param {UserGetUsersByCountryRequest} [userGetUsersByCountryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userGetUsersByCountry(
      userGetUsersByCountryRequest?: UserGetUsersByCountryRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .userGetUsersByCountry(userGetUsersByCountryRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
  /**
   * Retrieves basic public information about a user including username, skills, and rankings
   * @summary Get user profile (lite)
   * @param {UserGetUserLiteRequest} [userGetUserLiteRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userGetUserLite(
    userGetUserLiteRequest?: UserGetUserLiteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .userGetUserLite(userGetUserLiteRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a list of users by country
   * @summary Get users by country
   * @param {UserGetUsersByCountryRequest} [userGetUsersByCountryRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userGetUsersByCountry(
    userGetUsersByCountryRequest?: UserGetUsersByCountryRequest,
    options?: RawAxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .userGetUsersByCountry(userGetUsersByCountryRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WorkOfferApi - axios parameter creator
 */
export const WorkOfferApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves detailed information about a specific work offer
     * @summary Get work offer by ID
     * @param {WorkOfferGetByIdRequest} [workOfferGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workOfferGetById: async (
      workOfferGetByIdRequest?: WorkOfferGetByIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/workOffer.getById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        workOfferGetByIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves work offer for a specific company
     * @summary Get work offer by company ID
     * @param {WorkOfferGetWorkOfferByCompanyIdRequest} [workOfferGetWorkOfferByCompanyIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workOfferGetWorkOfferByCompanyId: async (
      workOfferGetWorkOfferByCompanyIdRequest?: WorkOfferGetWorkOfferByCompanyIdRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/workOffer.getWorkOfferByCompanyId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        workOfferGetWorkOfferByCompanyIdRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a paginated list of work offers with optional user and region filtering
     * @summary Get paginated work offers
     * @param {WorkOfferGetWorkOffersPaginatedRequest} [workOfferGetWorkOffersPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workOfferGetWorkOffersPaginated: async (
      workOfferGetWorkOffersPaginatedRequest?: WorkOfferGetWorkOffersPaginatedRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/workOffer.getWorkOffersPaginated`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        workOfferGetWorkOffersPaginatedRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WorkOfferApi - functional programming interface
 */
export const WorkOfferApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    WorkOfferApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves detailed information about a specific work offer
     * @summary Get work offer by ID
     * @param {WorkOfferGetByIdRequest} [workOfferGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workOfferGetById(
      workOfferGetByIdRequest?: WorkOfferGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.workOfferGetById(
          workOfferGetByIdRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WorkOfferApi.workOfferGetById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves work offer for a specific company
     * @summary Get work offer by company ID
     * @param {WorkOfferGetWorkOfferByCompanyIdRequest} [workOfferGetWorkOfferByCompanyIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workOfferGetWorkOfferByCompanyId(
      workOfferGetWorkOfferByCompanyIdRequest?: WorkOfferGetWorkOfferByCompanyIdRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.workOfferGetWorkOfferByCompanyId(
          workOfferGetWorkOfferByCompanyIdRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WorkOfferApi.workOfferGetWorkOfferByCompanyId"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves a paginated list of work offers with optional user and region filtering
     * @summary Get paginated work offers
     * @param {WorkOfferGetWorkOffersPaginatedRequest} [workOfferGetWorkOffersPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workOfferGetWorkOffersPaginated(
      workOfferGetWorkOffersPaginatedRequest?: WorkOfferGetWorkOffersPaginatedRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.workOfferGetWorkOffersPaginated(
          workOfferGetWorkOffersPaginatedRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WorkOfferApi.workOfferGetWorkOffersPaginated"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * WorkOfferApi - factory interface
 */
export const WorkOfferApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WorkOfferApiFp(configuration);
  return {
    /**
     * Retrieves detailed information about a specific work offer
     * @summary Get work offer by ID
     * @param {WorkOfferGetByIdRequest} [workOfferGetByIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workOfferGetById(
      workOfferGetByIdRequest?: WorkOfferGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .workOfferGetById(workOfferGetByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves work offer for a specific company
     * @summary Get work offer by company ID
     * @param {WorkOfferGetWorkOfferByCompanyIdRequest} [workOfferGetWorkOfferByCompanyIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workOfferGetWorkOfferByCompanyId(
      workOfferGetWorkOfferByCompanyIdRequest?: WorkOfferGetWorkOfferByCompanyIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .workOfferGetWorkOfferByCompanyId(
          workOfferGetWorkOfferByCompanyIdRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a paginated list of work offers with optional user and region filtering
     * @summary Get paginated work offers
     * @param {WorkOfferGetWorkOffersPaginatedRequest} [workOfferGetWorkOffersPaginatedRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workOfferGetWorkOffersPaginated(
      workOfferGetWorkOffersPaginatedRequest?: WorkOfferGetWorkOffersPaginatedRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .workOfferGetWorkOffersPaginated(
          workOfferGetWorkOffersPaginatedRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WorkOfferApi - object-oriented interface
 */
export class WorkOfferApi extends BaseAPI {
  /**
   * Retrieves detailed information about a specific work offer
   * @summary Get work offer by ID
   * @param {WorkOfferGetByIdRequest} [workOfferGetByIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public workOfferGetById(
    workOfferGetByIdRequest?: WorkOfferGetByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return WorkOfferApiFp(this.configuration)
      .workOfferGetById(workOfferGetByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves work offer for a specific company
   * @summary Get work offer by company ID
   * @param {WorkOfferGetWorkOfferByCompanyIdRequest} [workOfferGetWorkOfferByCompanyIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public workOfferGetWorkOfferByCompanyId(
    workOfferGetWorkOfferByCompanyIdRequest?: WorkOfferGetWorkOfferByCompanyIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return WorkOfferApiFp(this.configuration)
      .workOfferGetWorkOfferByCompanyId(
        workOfferGetWorkOfferByCompanyIdRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a paginated list of work offers with optional user and region filtering
   * @summary Get paginated work offers
   * @param {WorkOfferGetWorkOffersPaginatedRequest} [workOfferGetWorkOffersPaginatedRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public workOfferGetWorkOffersPaginated(
    workOfferGetWorkOffersPaginatedRequest?: WorkOfferGetWorkOffersPaginatedRequest,
    options?: RawAxiosRequestConfig
  ) {
    return WorkOfferApiFp(this.configuration)
      .workOfferGetWorkOffersPaginated(
        workOfferGetWorkOffersPaginatedRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
